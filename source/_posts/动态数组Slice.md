---
title: 动态数组Slice
date: 2021-10-12 09:35:53
tags: GoLang
categories: 学习
---
-
<!-- more -->

## 数组

数组是一种抽象的数据结构，他代表了一个相同类型元素的集合，计算机会为数组分配一块连续的内存区域来保存元素，我们可以通过下标快速访问特定元素。

### GoLang数组的内存区域

在不考虑内存逃逸的情况下，数组中的所有元素最终都是存储在栈中【如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上】-> 不知道为啥要这么设计。。

### GoLang数组总结

数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成直接读写内存。【奈何编译原理的知识储备不足，很多GoLang数组的底层特性无法深入，但是学编译原理的性价比太低了】

## GoLang切片

数组在编译期间必须确定大小，使用起来不太方便，所以在 Go 语言中没那么常用，更常用的数据结构是切片，即动态数组，其长度并不固定，我们可以向切片中追加元素，它会在容量不足时自动扩容。

### 切片的数据结构

切片本质就是一个结构体，源码如下

```go
type SliceHeader struct {
    Data uintptr // 元素指针
    len   int // 长度 
    cap   int // 容量
}
```

`slice` 共有三个属性： `指针`，指向底层数组； `长度`，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度； `容量`，底层数组的元素个数，容量 >= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。

### 切片的内存区域

当切片发生逃逸或者非常大时，运行时需要 [`runtime.makeslice`](https://draveness.me/golang/tree/runtime.makeslice) 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，`make([]int, 3, 4)` 会被直接转换成如下所示的代码

```go
var arr [4]int
n := arr[:3]
```

### append

append会向底层的数组追加元素，如果底层数组已满会触发扩容机制，在内存中新找一片区域作为新的底层数组。

扩容机制

1. 如果期望容量大于当前容量的两倍就会使用期望容量；
2. 如果当前切片的长度小于 1024 就会将容量翻倍；
3. 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量;

## 总结

切片虽然十分灵活，但是切片的追加操作会引起内存的扩容和拷贝，大规模的内存拷贝十分影响程序的性能，所以使用切片前最好估计一下需要的内存最大值，然后一次性申请个大切片【超过限制的申请会直接panic】。

## 参考资料

[golangSlice的扩容规则](https://jodezer.github.io/2017/05/golangSlice的扩容规则)

[Drave切片解析](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/#324-%E8%BF%BD%E5%8A%A0%E5%92%8C%E6%89%A9%E5%AE%B9)

[深度解密Golang切片](https://zhuanlan.zhihu.com/p/61121325)

